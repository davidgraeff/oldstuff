Linux Remotes
Preliminary codename: Liri - LInux Remote Infrastructure
Disclaimer: This framework uses qt4core. If you do not like qt from nokia for
whatever reason this set of applications is not for you.

Content:
1) What is Liri?
2) Building from source
3) Howto use liri
4) Why not helping lirc?
5) Other OSs
6) Folder structure
7) How to write a driver?
8) More information
9) License

If you want to help out with designing, developing or translating the tools,
the website or documentation please drop me a mail (david.graeff@cs.udo.edu).
Be aware that this text may not be up to date. Consider using the website for
the latest news and information.

Because english is not my mother tongue you will probably notice a few (or more;)
mistakes in this text. I would appreciate if you help me to sort them out :)

Sincerely,
david

Jan 7th, 2009

####################################
1) What is Liri?
Technical summary:
- Written in c++ with additional support via the qt4 framework.
- Drivers are pure c++ though
- Only linux supported (libudev for device discovery is not cross platform)
- GUI Tools, developed with the kde development platform 4.
- Uses dbus to control applications. No special support needed by target applications.
Statistics:
- About 200 source code files
- About 30 data/media files

The tools and programs in this package aim to provide a full linux remote
control infrastructure. Due to using many new possibilities that modern hardware
and newer linux distributions provide features such as receiver hotplugging and
instant-use is possible. You can install new drivers without recompiling or
restarting the device daemon. It is easy for users connecting and instantly
using new devices and also to use several remote control receivers at the same
time that was not possible or difficult to set up on other linux remote control
solutions.

No kernel drivers are needed, so there is no need to recompile modules with
every new kernel release. Legacy hardware, on the downside, that uses deprecated
ports like the parallel port or RS232 are not supported. But you can build a
homebrew usb infrared receiver for just 7â‚¬/$ or even buy a 433Mhz radio remote control
(in europe) for the same amount, so no problem here.

Graphical user interfaces are provided for the KDE 4 desktop to edit
remote-control-key-layouts, desktop profiles, application profiles, to associate profiles
to remotes and change various other settings but also to monitor and control the framework.

The device manager daemon lirid and the execution engine liriexec don't need
a running X Server.

####################################
2) Building from source
- You have to satisfy the following dependencies first:
  ALL: libqt4-core >= 4.4.3, libqt4-dbus >= 4.4.3
  USB DRIVERS: libusb
  FIREWIRE DRIVERS: libraw1394
  GUI KDE4: libqt4-gui >= 4.4.3, kdelibs >= 4.2

- Create a build directory, e.g. ./build.
- Change to that directory and enter "cmake ../". Default install prefix is /usr.
  Override with -DCMAKE_INSTALL_PREFIX=/any/path.
- Run "make" to actually build. (Increase job count on multicores with e.g. -j4)
- To install just type in "make install". (You probably need root privileges to install)

####################################
3) How-to use liri

Device Manager (lirid):
Supported remote receivers trigger the start of the liri device manager (lirid).
That daemon is responsible for receiving events from devices and propagate them
over the system bus (dbus). Device associated remote-control key layouts are loaded
automatically, too. Hint: Use "liri-control --messages" to see if
remote events are received properly.

Execution Engine (liriexec):
Has to be started by the user if the autostart file in data/autostart was not
installed to $HOME/.config/autostart. This program, running in the background,
listen to events from the device manager, in particular to key press
and device connection/disconnection events. On a device connection event liriexec
loads the assigned "desktop profiles".
Desktop profiles combine various "application profiles". This structure allows
to switch to a set of totally different target applications with one click.
E.g. for switching from a home theater desktop (where you controlled Amarok, VLC,
DragonPlayer and such) to a presentation desk (Okular, Browser, etc).

Editor (liri-editor-kde4):
Associate remotes to devices and profiles to remotes to define which profiles
should be loaded when a new device has been detected. Edit remote-key-layouts
for the remote controls that your receiver supports. Edit desktop profiles that
bundle application profiles to compose the perfect selection of applications for
your desktop environment. Edit application profiles to support your favourite
dbus-aware applications (all KDE4, most gnome applications) or execute other
actions that should take place (like starting any process, change current mode
etc) when you press remote keys.

Control (liri-control, liri-control-kde4):
You can monitor the health of the framework (lirid, liriexec and installed drivers)
with this tool. The commandline application provides a list of all supported
commands via liri-control --help. The gui applications are largly self-explanatory.

Notifications:
If you want to be notified about events like a plugged in device, a disconnected
device, loaded remote description files etc start the legacy tool "liri-tray" or 
on kde4.4+ add the plasmoid "liri notifications" to your desktop or panel.

####################################
4) Why not helping lirc?
Lirc is a historical grown code base. Unfortunately this is very obvious. Used
technologies are no longer in active development, some design decisions prevent a
user friendly way of configuring the program. It is quite difficult to add new drivers
and the driver interface consider things like puls lengths, gaps and decoding algorithms.
Newer devices do that on hardware level already and just propagate key events.
For the sake of usability a modern remote-control framework should no longer bother
with really legacy ports such as the LPT, or RS232. USB, Firewire, Bluetooth are technologies
where hotplugging is available and key layouts can be associated to specific hardware.

Lirc has a few of those raised design shortcomings. It does not provide a
mechanism to let applications know of new devices and does not support multiple
devices. Applications need to integrate and explicitly support lirc,
where as this framework only require a reasonably exported dbus interface.
All kde4 applications and most modern gnome applications
like rhythmbox, totem etc support dbus and are therefore supported by this
framework, as long as a profile is written for them.

####################################
5) Other OSs
QT and libusb for the usb drivers are also available for other operating systems
like BSD, Solaris, Mac and Windows. In theory it would be possible to port liri
programs and usb drivers to other os's but I didn't try so far.

####################################
6) Folder structure
./doc: Brief documentation of some important aspects like file formats. These docs
	are always up to date but have several issues concerning the layout, readabilty and
	consistent use of one language.

./data/: Non binary data
./data/autostart: The autostart file for liriexec.
	Copy this to $HOME/.config/autostart
./data/images: Images, Icons

./data/dbus_policy: Dbus policies. Eg only root can own org.liri.Devices
./data/dbus_service: Dbus service files.
	Used by the hal callout to start the device manager on plugged devices.

./data/modprobe.d: Don't allow lirc kernel drivers to be loaded.
	They clash with drivers provided by this framework.
./data/profiles: Desktop and Applicationprofiles
./data/remotes: Remote description files
./data/remote_load_profiles: Which desktop profile is associated to which remote.
./data/systemconfig: A default config file for lirid. Installed to /etc/lirid

./src: Source code

./src/businterconnect: Shared code for proxy dbus<->c++ objects
./src/fileformats: Shared code for reading and writing remotes and profiles
./src/unittests: Unit tests for shared code

./src/drivers: All drivers
./src/lirid: Device manager / Receiving process
./src/liristarter: Starts lirid if not already running on device plug events
./src/liriexec: Executes commands of profiles
./src/liriconfig: the commandline tool to control and monitor the framework

./src/gui/gnome2: Gui programs for gtk+
./src/gui/kde4: Gui programs for qt4/kde4

####################################
7) How to write a driver?
Up to date information on this topic is on the website. In a nutshell:
If you for example want to write a usb driver copy any driver directory
(preferable the ati one) from ./src/drivers/usb/ati to a new directory with the
name of your driver. Adapt the content of the driver.desktop and driver.rules file
to your device. Now you just have to rewrite the code in driver.cpp.

1) Change the defines DRIVER_VERSION and DRIVER_ID in driver.desktop.
2) Driver.cpp: Open your device in open.
   Initialize your device in init. You can block the process for a short time if necessary.
3) Implement "activity". You may not block the thread, but that function should be called only
   if new data is available anyway.

####################################
8) More information
Please visit the website http://cerebro.webhop.net/liri for more information!

####################################
9) License
GPL v2 and GPL v3
Uses QT from Nokia/Trolltech which is licensed under GPL v2 and GPL v3.
Uses libusb for usb drivers which is licensed under LGPL 2.1.
Uses libraw1394 for firewire drivers which is licensed under LGPL.
